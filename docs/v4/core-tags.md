# 核心标签和属性

Marko 提供了许多标签

## 控制流

### `<if>`, `<else-if>`, `<else>`

`<if>`、 `<else-if>` 和 `<else>` 标签为模版提供了条件控制流。

```xml
<if(arriving)>
    <div>Hey there</div>
</if>
<else-if(leaving)>
    <div>Bye now</div>
</else-if>
<else>
    <div>What's up?</div>
</else>
```

条件也可以应用在属性上：

```xml
<div if(arriving)>Hey there</div>
<div else-if(leaving)>Bye now</div>
<div else>What's up?</div>
```

并支持复杂表达式：

```xml
<if(Math.random() > 0.5)>
    <div>50-50 chance of seeing this</div>
</if>
```

### `<for>`

`<for>` 标签允许迭代一个数组：

```xml
<ul>
    <for(color in colors)>
        <li>${color}</li>
    </for>
</ul>
```

它也可以在属性中使用：

```xml
<ul>
    <li for(color in colors)>${color}</li>
</ul>
```

上面的任意一个模版中使用下面的  `colors` 值：

```js
var colors = ['red', 'green', 'blue'];
```

都会生成下面的的 HTML：

```html
<ul>
    <li>red</li>
    <li>green</li>
    <li>blue</li>
</ul>
```

#### 循环状态变量

如果你需要知道当前循环索引，`for` 指令支持循环状态变量，例如：

```xml
<ul>
    <li for(color in colors | status-var=loop)>
        ${color}
        ${loop.getIndex()+1}) of ${loop.getLength()}
        <if(loop.isFirst())> - FIRST</if>
        <if(loop.isLast())> - LAST</if>
    </li>
</ul>
```

##### 循环状态方法

###### `getLength()`

返回数组的长度

###### `getIndex()`

返回当前循环索引

###### `isFirst()`

如果当前索引是第一个，会返回 `true`，不是的话返回 `false`

###### `isLast()`

如果当前索引是最后个，会返回 `true`，不是的话返回 `false`

#### 循环分割器

用来通过字符去分割值。使用 `separator`，第一个元素不会加前缀，最后一个元素不会加后缀：

```xml
<div>
    <!-- Output: red, green, blue -->
    <span for(color in colors | separator=", ") style="color: ${color}">
        ${color}
    </span>
</div>
```

#### 域循环

可以用下面的格式来提供一个域：`<var-name> from <from> to <to>[ step <step>]`。

`from`、 `to` 和 `step` 的值必须是数字表达式。如果没有明确指定，默认步长为1。

```xml
<ul>
    <li for(i from 0 to 10)>
        ${i}
    </li>
</ul>
```

```xml
<ul>
    <li for(i from 0 to 10 step 2)>
        ${i}
    </li>
</ul>
```

```xml
<ul>
    <li for(i from 0 to myArray.length-1)>
        ${myArray[i]}
    </li>
</ul>
```

#### 属性值循环

```xml
<ul>
    <li for(name, value in settings)>
        <b>${name}</b>: ${value}
    </li>
</ul>
```

#### 原始 JavaScript 的 for 循环

```xml
<for(var i=1; i<=3; i++)>
    ${i}
</for>
```

#### 自定义迭代器


```xml
static function reverseIterator(arrayList, callback) {
    for(var i=arrayList.length-1; i>=0; i--){
        callback(arrayList[i]);
    }
}

<div for(item in ['a', 'b', 'c'] | iterator=reverseIterator)>
    ${item}
</div>
```

Output:

```html
<div>c</div>
<div>b</div>
<div>a</div>
```

### `<while>`

使用 `while` 指令，任何元素都可以迭代到满足一个条件为止。这个制定既可以作为元素使用，又可以作为属性使用。

_作为属性使用：_

```xml
$ var n = 0;

<ul>
    <li while(n < 4)>
        ${n++}
    </li>
</ul>
```

_作为元素使用：_

```xml
$ var n = 0;

<ul>
    <while(n < 4)>
        <li>${n++}</li>
    </while>
</ul>
```

### `body-only-if`

如果你发现你有一个封装元素是有条件的，但是它的主体应该永远被渲染，那么你就可以使用 `body-only-if` 属性来处理这种情况。例如，如果有一个有效的URL，为了只渲染封装的 `<a>` 标签，你可以像下面这样做：

```xml
<a href=input.linkUrl body-only-if(!input.linkUrl)>
    Some body content
</a>
```

为 `input.linkUrl` 变量赋一个 `"http://localhost/"` 值，会有如下的输出：

```xml
<a href="http://localhost/">
    Some body content
</a>
```

为 `input.linkUrl` 变量赋一个 `undefined` 值，会有如下的输出：

```xml
Some body content
```

## JavaScript

即便使用 HTML 的语法标签来生成 HTML 输出，下面的标签需要使用[简易语法](./concise.md)。

### `import`
> **Static:** The code generated by `import` will run once when the template is loaded and be shared by all calls to render. It must be declared as a top level tag and does not have access to `data`, `state`, or other values passed in at render.

The `import` tag is used to access data and functions from external files.  It follows the same syntax as the [JavaScript `import` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import).

```xml
import sum from './utils/sum';
<div>The sum of 2 + 3 is ${sum(2, 3)}</div>
```

### `<export>`
> **Static:** The code generated by `export` will run once when the template is loaded and be shared by all calls to render. It must be declared as a top level tag and does not have access to `data`, `state`, or other values passed in at render.

The `export` tag is used to export values from the template.  It follows the same syntax as the [JavaScript `export` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export), but only named exports are supported (the default export is the template).

```xml
export var route = '/about';

<!doctype html>
<html>
    <body>
        <h1>About us</h1>
    </body>
</html>
```

## Reusable content

### `<include>`

The include tag is used to embed another template (or part of another template) in the current template.

The include tag can take a path to a template as the first argument:

```xml
<include('./path/to/template.marko')/>
```

The second argument may be used to pass input to the included template:

```xml
<include('./path/to/template.marko', { name:'Frank' })/>
```

Attributes may also be used to pass data to the included template and can be used in combination with the input parameter:

```xml
<include('./path/to/template.marko', data) name="Frank"/>
```

#### Layouts with nested attributes

In addition to including external content, you can inject additional content chunks into the external content.  This is accomplished by using nested attribute tags which are denoted by the `@` symbol:

_page.marko_
```xml
<include('./layout.marko')>
    <@body>
        <h1>Hello Marko</h1>
    </@body>
</include>
```

Then in your layout template you can include the injected content:

_layout.marko_
```xml
<!doctype html>
<html>
    <body>
        <!-- this comes from <@body> -->
        <include(input.body)/>
    </body>
</html>
```

<!--
- You can use many nested attribute tags for multiple injection points
- You can have repeated nested attribute tags by using `marko-tag.json` (components only)
- You can add additional attributes to an nested attribute tag
- You can pass data to a nested attribute tag's body?
-->

### `<include-text>`

```xml
<include-text('./foo.txt')/>
```

Special HTML characters will be escaped. If you do not want escaping then use the `<include-html>` tag (see below).

### `<include-html>`

```xml
<include-html('./foo.html')/>
```

Special HTML characters will _not_ be escaped since the file is expected to be an HTML file.

### `<macro>`

Parameterized macros allow for reusable fragments within an HTML template.
A macro can be defined using the `<macro>` directive.

```xml
<macro greeting(name, count)>
    Hello ${name}! You have ${count} new messages.
</macro>
```

The above macro can then be invoked as part of any expression. The following
sample template shows how to use macro functions inside expressions:

```xml
<macro greeting(name, count)>
    Hello ${name}! You have ${count} new messages.
</macro>
<p>
    <greeting("John", 10)/>
</p>
<p>
    <!-- Or, using named attributes: -->
    <greeting name="Frank" count=20/>
</p>
```

## Async content

### `<await>`

The `<await>` tag is used to dynamically load in content from a data provider. The data provider can be a `Promise` or a `callback`. Once the provider returns it's results the children are rendered.

await-example.marko
```xml
$ var personPromise = new Promise((resolve, reject) => {
    setTimeout(function() {
        resolve({
            name: 'Frank'
        });
    }, 1000);
});

<await(person from personPromise)>
    <div>Hello ${person.name}!</div>
</await>
```

Advanced implementation:
+ <await> tag signature
    * Basic usage: <await(results from dataProvider)>...</await>
    * Optional attributes
        - client-reorder `boolean`
        - arg `expression`
        - arg-* `string`
        - method `string`
        - timeout `integer`
        - timeout-message `string` 
        - error-message `string`
        - placeholder `string`
        - renderTimeout `function`
        - renderError `function`
        - renderPlaceholder `function`
        - name `string`
        - scope `expression`
        - show-after `string`
    * Optional child tags
        - <await-placeholder>Loading...</await-placeholder>
        - <await-timeout>Request timed out</await-timeout>
        - <await-error>Request errored</await-error>

## Comments

Standard HTML comments can be used to add comments to your template. The HTML comments will not show up in the rendered HTML.

Example comments:

```xml
<!-- This is a comment that will not be rendered -->
<h1>Hello</h1>
```

```js
// You can also use standard JavaScript-style comments
/*
 Block comments are also supported
 */
-- Hello
```

If you would like for your HTML comment to show up in the final output then you can use the custom `html-comment` tag.

### `<html-comment>`

_input.marko_
```xml
<html-comment>This is a comment that *will* be rendered</html-comment>
<h1>Hello</h1>
```

_output.html_
```html
<!--This is a comment that *will* be rendered-->
<h1>Hello</h1>
```

Alternatively, the `<marko-compiler-options>` tag may be used to configure comments for the entire template:
```xml
<marko-compiler-options preserve-comments/>
```

## Compiler options

### `marko-preserve-whitespace`

Whitespace can be preserved using the `preserve-whitespace` attribute:

```xml
<div marko-preserve-whitespace>
    All of this
    whitespace   will
    be preserved.
</div>
```
Alternatively, the `<marko-compiler-options>` tag may be used to configure whitespace for the entire template:

```xml
<marko-compiler-options preserve-whitespace/>
```

### `marko-body`

The `marko-body` attribute can be used to control how body content is parsed. The following values are supported:
- `html` - Body content will be parsed HTML (the default)
- `static-text` - Body content will be parsed as static text (HTML tags will be ignored). Placeholders will be ignored.
- `parsed-text` - Body content will be parsed as text (HTML tags will be ignored). Placeholders will not be ignored.

_input.marko_
```xml
<div marko-body="static-text">
    This is just one
    <span if(foo)>
            Hello ${THIS IS NOT VALID}!
    </span>
    big text block
</div>
```

_output.html_
```html
<div>
    This is just one
    &lt;span if(foo)&gt;
        Hello ${THIS IS NOT VALID}!
    &lt;/span&gt;
    big text block
</div>
```
